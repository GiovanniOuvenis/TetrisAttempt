
    /*
    // removes welcome message
    const removeWelcome = () => {
        const welcomeElement = document.getElementById("welcome");
        welcomeElement.classList.add("disappear");    
        setPlaying(playing=> !playing
        );
    }

    // removes pause message 
        const removePause = () => {
            const pauseElement = document.getElementById("pause");
            pauseElement.classList.add("disappear");
        }
        
                // Fills every context state value with information. Used as effect in useEffect 
                    const pickNextPiece = (objArg) => {
                         let result = pickShape();
                        objArg = {...result};        
                        return objArg;
                    } */        
           

             // In the first render every state value is going to be blank. After the first render every piece is set to be the next one 
            // e.g first receives value from second, second gets value from the third and only third receives a new value. 
                  /*  useEffect(() => {        
                        setNextPiece(()=>{
                         if (Object.keys(nextPiece).length === 0) {
                             return pickNextPiece(nextPiece);
                         }
                         else {
                             return secondPiece;
                         }
                        }) 
                        setSecondPiece(()=>{
                            if (Object.keys(secondPiece).length === 0){
                                return pickNextPiece(secondPiece);
                            }
                            else {
                                return thirdPiece;
                            }
                        })
                        setThirdPiece(()=>{
                            return pickNextPiece(thirdPiece);
                         })
                     },[]) */
   // We need to push the current pieces to the occupied array before the following effects run and we
   //set new positions and colors



   // check for collision

/*useEffect(()=> {
   const collisionDone = (e) => {
       if (e.keyCode === 40 ) {
     setCollision((collision) => {
       let check =  positionOfCurrentPiece.map((collided) => {
            if (collided >= 210) {
                return true;
            } else if (occupied.includes(collided + 10)) {
                return true;
            }
         })

         if (check.includes(true)) {
             return !collision
         } else {
             return collision;
         }
             
        })
   }
}

   window.addEventListener("keyup", collisionDone)
},[])*/